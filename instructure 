# Complete NFT Marketplace Development Guide - AI Coder Prompt

You are an expert blockchain developer tasked with building a complete NFT marketplace from scratch. Follow this comprehensive guide to create a production-ready application similar to OpenSea.

## 🎯 Project Goals
Build a full-stack NFT marketplace where users can:
- Mint NFTs (ERC-721 and ERC-1155)
- List NFTs for sale (fixed price + auctions)
- Browse and purchase NFTs
- Manage collections and profiles

## 📋 Step-by-Step Development Plan

### Phase 1: Project Setup & Environment Configuration

#### Step 1.1: Initialize the Project Structure
```bash
# Create project directory
mkdir nft-marketplace
cd nft-marketplace

# Initialize separate folders
mkdir smart-contracts
mkdir frontend
```

#### Step 1.2: Smart Contract Setup
```bash
cd smart-contracts
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox
npx hardhat
```

**Required Dependencies:**
```json
{
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^3.0.0",
    "@openzeppelin/contracts": "^4.9.0",
    "hardhat": "^2.17.0"
  }
}
```

#### Step 1.3: Frontend Setup
```bash
cd ../frontend
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir
npm install ethers@^5.7.2 wagmi viem @rainbow-me/rainbowkit
npm install @pinata/sdk ipfs-http-client
```

### Phase 2: Smart Contract Development

#### Step 2.1: Create NFT Contract (ERC-721)
**File: `contracts/NFTCollection.sol`**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract NFTCollection is ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    mapping(uint256 => address) public creators;
    mapping(uint256 => uint256) public royaltyPercentage;
    
    event NFTMinted(uint256 indexed tokenId, address indexed creator, string tokenURI);
    
    constructor() ERC721("NFT Marketplace", "NFTM") {}
    
    function mintNFT(
        address recipient,
        string memory tokenURI,
        uint256 royalty
    ) public returns (uint256) {
        require(royalty <= 1000, "Royalty too high"); // Max 10%
        
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        _mint(recipient, newTokenId);
        _setTokenURI(newTokenId, tokenURI);
        
        creators[newTokenId] = msg.sender;
        royaltyPercentage[newTokenId] = royalty;
        
        emit NFTMinted(newTokenId, msg.sender, tokenURI);
        return newTokenId;
    }
    
    function getRoyaltyInfo(uint256 tokenId) external view returns (address, uint256) {
        return (creators[tokenId], royaltyPercentage[tokenId]);
    }
}
```

#### Step 2.2: Create Marketplace Contract
**File: `contracts/NFTMarketplace.sol`**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract NFTMarketplace is ReentrancyGuard, Ownable {
    struct Listing {
        uint256 tokenId;
        address nftContract;
        address seller;
        uint256 price;
        bool active;
        bool isAuction;
        uint256 auctionEndTime;
        address highestBidder;
        uint256 highestBid;
    }
    
    mapping(uint256 => Listing) public listings;
    mapping(address => mapping(uint256 => uint256)) public tokenToListingId;
    
    uint256 public listingCounter;
    uint256 public marketplaceFee = 250; // 2.5%
    
    event ItemListed(uint256 indexed listingId, address indexed nftContract, uint256 indexed tokenId, uint256 price);
    event ItemSold(uint256 indexed listingId, address buyer, uint256 price);
    event BidPlaced(uint256 indexed listingId, address bidder, uint256 amount);
    
    function listItem(
        address nftContract,
        uint256 tokenId,
        uint256 price,
        bool isAuction,
        uint256 auctionDuration
    ) external {
        IERC721 nft = IERC721(nftContract);
        require(nft.ownerOf(tokenId) == msg.sender, "Not owner");
        require(nft.isApprovedForAll(msg.sender, address(this)), "Not approved");
        
        listingCounter++;
        
        listings[listingCounter] = Listing({
            tokenId: tokenId,
            nftContract: nftContract,
            seller: msg.sender,
            price: price,
            active: true,
            isAuction: isAuction,
            auctionEndTime: isAuction ? block.timestamp + auctionDuration : 0,
            highestBidder: address(0),
            highestBid: 0
        });
        
        tokenToListingId[nftContract][tokenId] = listingCounter;
        
        emit ItemListed(listingCounter, nftContract, tokenId, price);
    }
    
    function buyItem(uint256 listingId) external payable nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(!listing.isAuction, "Item is auction");
        require(msg.value >= listing.price, "Insufficient payment");
        
        listing.active = false;
        
        // Calculate fees and royalties
        uint256 marketplaceFeeAmount = (msg.value * marketplaceFee) / 10000;
        uint256 sellerAmount = msg.value - marketplaceFeeAmount;
        
        // Transfer NFT
        IERC721(listing.nftContract).safeTransferFrom(
            listing.seller,
            msg.sender,
            listing.tokenId
        );
        
        // Transfer payments
        payable(listing.seller).transfer(sellerAmount);
        
        emit ItemSold(listingId, msg.sender, msg.value);
    }
    
    function placeBid(uint256 listingId) external payable nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(listing.isAuction, "Not an auction");
        require(block.timestamp < listing.auctionEndTime, "Auction ended");
        require(msg.value > listing.highestBid, "Bid too low");
        
        // Refund previous bidder
        if (listing.highestBidder != address(0)) {
            payable(listing.highestBidder).transfer(listing.highestBid);
        }
        
        listing.highestBidder = msg.sender;
        listing.highestBid = msg.value;
        
        emit BidPlaced(listingId, msg.sender, msg.value);
    }
    
    function endAuction(uint256 listingId) external nonReentrant {
        Listing storage listing = listings[listingId];
        require(listing.active, "Listing not active");
        require(listing.isAuction, "Not an auction");
        require(block.timestamp >= listing.auctionEndTime, "Auction still active");
        
        listing.active = false;
        
        if (listing.highestBidder != address(0)) {
            // Calculate fees
            uint256 marketplaceFeeAmount = (listing.highestBid * marketplaceFee) / 10000;
            uint256 sellerAmount = listing.highestBid - marketplaceFeeAmount;
            
            // Transfer NFT to winner
            IERC721(listing.nftContract).safeTransferFrom(
                listing.seller,
                listing.highestBidder,
                listing.tokenId
            );
            
            // Transfer payment to seller
            payable(listing.seller).transfer(sellerAmount);
            
            emit ItemSold(listingId, listing.highestBidder, listing.highestBid);
        }
    }
}
```

#### Step 2.3: Deployment Script
**File: `scripts/deploy.js`**

```javascript
const hre = require("hardhat");

async function main() {
    // Deploy NFT Collection
    const NFTCollection = await hre.ethers.getContractFactory("NFTCollection");
    const nftCollection = await NFTCollection.deploy();
    await nftCollection.deployed();
    console.log("NFTCollection deployed to:", nftCollection.address);
    
    // Deploy Marketplace
    const NFTMarketplace = await hre.ethers.getContractFactory("NFTMarketplace");
    const marketplace = await NFTMarketplace.deploy();
    await marketplace.deployed();
    console.log("NFTMarketplace deployed to:", marketplace.address);
    
    // Save contract addresses
    const fs = require('fs');
    const contractAddresses = {
        nftCollection: nftCollection.address,
        marketplace: marketplace.address
    };
    
    fs.writeFileSync(
        '../frontend/src/contracts/addresses.json',
        JSON.stringify(contractAddresses, null, 2)
    );
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
```

### Phase 3: Frontend Development

#### Step 3.1: Web3 Configuration
**File: `src/lib/web3Config.ts`**

```typescript
import { getDefaultWallets } from '@rainbow-me/rainbowkit';
import { configureChains, createConfig } from 'wagmi';
import { mainnet, polygon, optimism, arbitrum, goerli } from 'wagmi/chains';
import { publicProvider } from 'wagmi/providers/public';

const { chains, publicClient } = configureChains(
    [mainnet, polygon, optimism, arbitrum, goerli],
    [publicProvider()]
);

const { connectors } = getDefaultWallets({
    appName: 'NFT Marketplace',
    projectId: process.env.NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID!,
    chains
});

export const wagmiConfig = createConfig({
    autoConnect: true,
    connectors,
    publicClient
});

export { chains };
```

#### Step 3.2: IPFS Integration
**File: `src/lib/ipfs.ts`**

```typescript
import { create as ipfsHttpClient } from 'ipfs-http-client';

const client = ipfsHttpClient({
    host: 'ipfs.infura.io',
    port: 5001,
    protocol: 'https',
    headers: {
        authorization: `Basic ${Buffer.from(
            `${process.env.NEXT_PUBLIC_INFURA_PROJECT_ID}:${process.env.NEXT_PUBLIC_INFURA_SECRET}`
        ).toString('base64')}`
    }
});

export const uploadToIPFS = async (file: File) => {
    try {
        const result = await client.add(file);
        return `https://ipfs.io/ipfs/${result.path}`;
    } catch (error) {
        console.error('IPFS upload error:', error);
        throw error;
    }
};

export const uploadMetadata = async (metadata: object) => {
    try {
        const result = await client.add(JSON.stringify(metadata));
        return `https://ipfs.io/ipfs/${result.path}`;
    } catch (error) {
        console.error('IPFS metadata upload error:', error);
        throw error;
    }
};
```

#### Step 3.3: Contract Hooks
**File: `src/hooks/useNFTContract.ts`**

```typescript
import { useContract, useProvider, useSigner } from 'wagmi';
import { ethers } from 'ethers';
import NFTCollectionABI from '../contracts/NFTCollection.json';
import MarketplaceABI from '../contracts/NFTMarketplace.json';
import addresses from '../contracts/addresses.json';

export const useNFTContract = () => {
    const provider = useProvider();
    const { data: signer } = useSigner();
    
    const nftContract = useContract({
        address: addresses.nftCollection,
        abi: NFTCollectionABI.abi,
        signerOrProvider: signer || provider
    });
    
    const marketplaceContract = useContract({
        address: addresses.marketplace,
        abi: MarketplaceABI.abi,
        signerOrProvider: signer || provider
    });
    
    const mintNFT = async (tokenURI: string, royalty: number = 250) => {
        if (!signer) throw new Error('Wallet not connected');
        
        const tx = await nftContract?.mintNFT(
            await signer.getAddress(),
            tokenURI,
            royalty
        );
        
        return await tx.wait();
    };
    
    const listNFT = async (
        tokenId: number,
        price: string,
        isAuction: boolean = false,
        auctionDuration: number = 86400 // 24 hours
    ) => {
        if (!signer) throw new Error('Wallet not connected');
        
        // First approve marketplace
        const approveTx = await nftContract?.setApprovalForAll(
            addresses.marketplace,
            true
        );
        await approveTx.wait();
        
        // Then list item
        const listTx = await marketplaceContract?.listItem(
            addresses.nftCollection,
            tokenId,
            ethers.utils.parseEther(price),
            isAuction,
            auctionDuration
        );
        
        return await listTx.wait();
    };
    
    const buyNFT = async (listingId: number, price: string) => {
        if (!signer) throw new Error('Wallet not connected');
        
        const tx = await marketplaceContract?.buyItem(listingId, {
            value: ethers.utils.parseEther(price)
        });
        
        return await tx.wait();
    };
    
    return {
        nftContract,
        marketplaceContract,
        mintNFT,
        listNFT,
        buyNFT
    };
};
```

#### Step 3.4: Create NFT Component
**File: `src/components/CreateNFT.tsx`**

```typescript
import { useState } from 'react';
import { useNFTContract } from '../hooks/useNFTContract';
import { uploadToIPFS, uploadMetadata } from '../lib/ipfs';

export default function CreateNFT() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [image, setImage] = useState<File | null>(null);
    const [loading, setLoading] = useState(false);
    const [royalty, setRoyalty] = useState(250); // 2.5%
    
    const { mintNFT } = useNFTContract();
    
    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!image) return;
        
        setLoading(true);
        try {
            // Upload image to IPFS
            const imageURL = await uploadToIPFS(image);
            
            // Create metadata
            const metadata = {
                name,
                description,
                image: imageURL,
                attributes: []
            };
            
            // Upload metadata to IPFS
            const metadataURL = await uploadMetadata(metadata);
            
            // Mint NFT
            await mintNFT(metadataURL, royalty);
            
            // Reset form
            setName('');
            setDescription('');
            setImage(null);
            
            alert('NFT created successfully!');
        } catch (error) {
            console.error('Error creating NFT:', error);
            alert('Error creating NFT');
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <div className="max-w-md mx-auto bg-white rounded-lg shadow-md p-6">
            <h2 className="text-2xl font-bold mb-6">Create New NFT</h2>
            
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label className="block text-sm font-medium mb-2">Name</label>
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        className="w-full border rounded-lg px-3 py-2"
                        required
                    />
                </div>
                
                <div>
                    <label className="block text-sm font-medium mb-2">Description</label>
                    <textarea
                        value={description}
                        onChange={(e) => setDescription(e.target.value)}
                        className="w-full border rounded-lg px-3 py-2 h-24"
                        required
                    />
                </div>
                
                <div>
                    <label className="block text-sm font-medium mb-2">Image</label>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={(e) => setImage(e.target.files?.[0] || null)}
                        className="w-full"
                        required
                    />
                </div>
                
                <div>
                    <label className="block text-sm font-medium mb-2">
                        Royalty ({royalty / 100}%)
                    </label>
                    <input
                        type="range"
                        min="0"
                        max="1000"
                        value={royalty}
                        onChange={(e) => setRoyalty(Number(e.target.value))}
                        className="w-full"
                    />
                </div>
                
                <button
                    type="submit"
                    disabled={loading}
                    className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50"
                >
                    {loading ? 'Creating...' : 'Create NFT'}
                </button>
            </form>
        </div>
    );
}
```

#### Step 3.5: Marketplace Grid Component
**File: `src/components/NFTGrid.tsx`**

```typescript
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useNFTContract } from '../hooks/useNFTContract';

interface NFTListing {
    id: number;
    tokenId: number;
    name: string;
    image: string;
    price: string;
    seller: string;
    isAuction: boolean;
    auctionEndTime?: number;
}

export default function NFTGrid() {
    const [listings, setListings] = useState<NFTListing[]>([]);
    const [loading, setLoading] = useState(true);
    
    const { marketplaceContract, nftContract, buyNFT } = useNFTContract();
    
    useEffect(() => {
        loadListings();
    }, []);
    
    const loadListings = async () => {
        try {
            // Get listing counter
            const listingCounter = await marketplaceContract?.listingCounter();
            const activeListings: NFTListing[] = [];
            
            for (let i = 1; i <= listingCounter; i++) {
                const listing = await marketplaceContract?.listings(i);
                
                if (listing.active) {
                    // Get token URI and metadata
                    const tokenURI = await nftContract?.tokenURI(listing.tokenId);
                    const response = await fetch(tokenURI);
                    const metadata = await response.json();
                    
                    activeListings.push({
                        id: i,
                        tokenId: listing.tokenId.toNumber(),
                        name: metadata.name,
                        image: metadata.image,
                        price: ethers.utils.formatEther(listing.price),
                        seller: listing.seller,
                        isAuction: listing.isAuction,
                        auctionEndTime: listing.auctionEndTime?.toNumber()
                    });
                }
            }
            
            setListings(activeListings);
        } catch (error) {
            console.error('Error loading listings:', error);
        } finally {
            setLoading(false);
        }
    };
    
    const handleBuyNFT = async (listingId: number, price: string) => {
        try {
            await buyNFT(listingId, price);
            loadListings(); // Refresh listings
        } catch (error) {
            console.error('Error buying NFT:', error);
            alert('Error buying NFT');
        }
    };
    
    if (loading) return <div>Loading...</div>;
    
    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {listings.map((listing) => (
                <div key={listing.id} className="bg-white rounded-lg shadow-md overflow-hidden">
                    <img 
                        src={listing.image} 
                        alt={listing.name}
                        className="w-full h-64 object-cover"
                    />
                    
                    <div className="p-4">
                        <h3 className="text-xl font-bold mb-2">{listing.name}</h3>
                        
                        <div className="flex justify-between items-center mb-4">
                            <span className="text-2xl font-bold">
                                {listing.price} ETH
                            </span>
                            
                            {listing.isAuction && (
                                <span className="bg-red-100 text-red-800 px-2 py-1 rounded text-sm">
                                    Auction
                                </span>
                            )}
                        </div>
                        
                        <p className="text-sm text-gray-600 mb-4">
                            Seller: {listing.seller.slice(0, 6)}...{listing.seller.slice(-4)}
                        </p>
                        
                        <button
                            onClick={() => handleBuyNFT(listing.id, listing.price)}
                            className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700"
                        >
                            {listing.isAuction ? 'Place Bid' : 'Buy Now'}
                        </button>
                    </div>
                </div>
            ))}
        </div>
    );
}
```

### Phase 4: Testing & Deployment

#### Step 4.1: Smart Contract Tests
**File: `test/NFTMarketplace.test.js`**

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("NFT Marketplace", function () {
    let nftCollection, marketplace;
    let owner, seller, buyer;
    
    beforeEach(async function () {
        [owner, seller, buyer] = await ethers.getSigners();
        
        const NFTCollection = await ethers.getContractFactory("NFTCollection");
        nftCollection = await NFTCollection.deploy();
        
        const NFTMarketplace = await ethers.getContractFactory("NFTMarketplace");
        marketplace = await NFTMarketplace.deploy();
        
        await nftCollection.deployed();
        await marketplace.deployed();
    });
    
    it("Should mint and list NFT", async function () {
        // Mint NFT
        await nftCollection.connect(seller).mintNFT(
            seller.address,
            "https://test-metadata.json",
            250
        );
        
        // Approve marketplace
        await nftCollection.connect(seller).setApprovalForAll(marketplace.address, true);
        
        // List NFT
        await marketplace.connect(seller).listItem(
            nftCollection.address,
            1,
            ethers.utils.parseEther("1"),
            false,
            0
        );
        
        const listing = await marketplace.listings(1);
        expect(listing.active).to.be.true;
        expect(listing.price).to.equal(ethers.utils.parseEther("1"));
    });
    
    it("Should buy NFT", async function () {
        // Setup: mint and list NFT
        await nftCollection.connect(seller).mintNFT(
            seller.address,
            "https://test-metadata.json",
            250
        );
        
        await nftCollection.connect(seller).setApprovalForAll(marketplace.address, true);
        
        await marketplace.connect(seller).listItem(
            nftCollection.address,
            1,
            ethers.utils.parseEther("1"),
            false,
            0
        );
        
        // Buy NFT
        await marketplace.connect(buyer).buyItem(1, {
            value: ethers.utils.parseEther("1")
        });
        
        // Check ownership transfer
        expect(await nftCollection.ownerOf(1)).to.equal(buyer.address);
        
        // Check listing is inactive
        const listing = await marketplace.listings(1);
        expect(listing.active).to.be.false;
    });
});
```

#### Step 4.2: Deployment Configuration
**File: `hardhat.config.js`**

```javascript
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

module.exports = {
    solidity: "0.8.19",
    networks: {
        goerli: {
            url: `https://eth-goerli.g.alchemy.com/v2/${process.env.ALCHEMY_API_KEY}`,
            accounts: [process.env.PRIVATE_KEY]
        },
        mainnet: {
            url: `https://eth-mainnet.g.alchemy.com/v2/${process.env.ALCHEMY_API_KEY}`,
            accounts: [process.env.PRIVATE_KEY]
        }
    },
    etherscan: {
        apiKey: process.env.ETHERSCAN_API_KEY
    }
};
```

### Phase 5: Advanced Features Implementation

#### Step 5.1: Add Auction Functionality
Enhance the frontend to handle auction bids with countdown timers and automatic auction ending.

#### Step 5.2: User Profiles
Create user profile pages showing owned NFTs, created NFTs, and trading history.

#### Step 5.3: Search & Filtering
Add search functionality by name, price range, and category filters.

#### Step 5.4: Mobile Responsive Design
Ensure the application works seamlessly on mobile devices.

## 🚀 Deployment Checklist

### Smart Contracts:
- [ ] Deploy to testnet (Goerli/Sepolia)
- [ ] Verify contracts on Etherscan
- [ ] Test all functions thoroughly
- [ ] Deploy to mainnet (when ready)

### Frontend:
- [ ] Configure environment variables
- [ ] Test wallet connections
- [ ] Deploy to Vercel/Netlify
- [ ] Set up custom domain

### Security:
- [ ] Audit smart contracts
- [ ] Test with different wallets
- [ ] Check for reentrancy attacks
- [ ] Validate all user inputs

## 📝 Documentation Requirements

Create comprehensive documentation including:
1. **README.md** with setup instructions
2. **API documentation** for smart contracts
3. **User guide** for the marketplace
4. **Architecture overview** diagram

## 🎯 Success Metrics

Your NFT marketplace should achieve:
- ✅ Users can mint NFTs with IPFS metadata
- ✅ Support for both fixed-price and auction listings
- ✅ Secure wallet integration
- ✅ Mobile-responsive design
- ✅ Gas-optimized smart contracts
- ✅ Comprehensive error handling
- ✅ Real-time transaction status updates

## 💼 Portfolio Impact

This project demonstrates:
- **Smart Contract Development**: Advanced Solidity patterns
- **Full-Stack Integration**: Web3 + React expertise
- **Decentralized Storage**: IPFS implementation
- **User Experience**: Intuitive blockchain interfaces
- **Security**: Best practices for DeFi applications

Focus on code quality, user experience, and security. This marketplace should serve as a flagship project in your blockchain development portfolio.